%import common.WS
%import common.INT
%import common.FLOAT
%ignore WS
%ignore COMMENT

// Top Level Declarations
start: top_level_decl

top_level_decl: statements?
statements: statement+

block: COLON statement* END
endblock: COLON statement*

statement: declaration | expression | import_declaration | return_exp | if_statement | else_statement | while_statement | for_statement

declaration: var_declaration | constant_declaration | function_declaration | class_declaration | bind_declaration | let_declaration | trait_declaration

// Expressions and Types
expression: assignment 
       | test

atom: number | identifier | bool_exp | string | parenthetical | array_type // | vartype
//comparison_exp: number | string | bool_exp | identifier
number: decimal_number | float_number | hex_number
string: /"(?:[^"\\]|\\.)*"/
decimal_number: DEC_NUMBER opt_vartype
float_number: FLOAT_NUMBER opt_vartype
hex_number: HEX_NUMBER opt_vartype
array_type: LBRACK array_comp RBRACK
array_comp: (test|star_expr) [for_comp | ("," (test|star_expr))+ [","] | ","]
bool_exp: TRUE | FALSE

return_exp: RETURN expression
echo_exp: ECHO expression

star_expr: "*" expression

conditional_statement: if_statement | else_statement | while_statement | for_statement

if_statement: IF comparison_block
else_statement: ELSE endblock | ELIF comparison_block
while_statement: WHILE comparison_block
for_statement: FOR expr_list IN comp_list_block else_statement?
for_comp: FOR expr_list IN or_test [comp_iter]
if_comp: IF test_nocond [comp_iter]
expr_list: (expression|star_expr) (COMMA (expression|star_expr))* [COMMA]
comparison_block: test block
comp_list_block: testlist block
testlist: test (COMMA test)* [COMMA]
?test_nocond: or_test
comp_iter: for_comp | if_comp

?atom_expr: atom_expr LPAREN opt_call_args RPAREN -> func_call
       | atom_expr LBRACK dimensions RBRACK -> array_ref
       | atom

dimensions: [dimension (COMMA dimension)*]
dimension: expression

?test: or_test
?or_test: and_test (OR and_test)*
?and_test: not_test (AND not_test)*
?not_test: NOT not_test | comparison
?comparison: add_ops (comp_op add_ops)*
?add_ops: mult_ops (add_op mult_ops)*
?mult_ops: factor_ops (mult_op factor_ops)*
?factor_ops: factor_op factor_ops | atom_expr

?comp_op: EQUALS|NOTEQUAL|GREATERTHAN|GREATEQUAL|LESSTHAN|LESSEQUAL
?add_op: PLUS|MINUS
?mult_op: MODULUS|MULTIPLY|INTDIV
?factor_op: NEGATIVE

parenthetical: LPAREN test RPAREN

//condition_list: comparison AND comparison | comparison OR comparison | RBRACE condition_list RBRACE | comparison

// comparison: comp_val eval_comparison_op comp_val | comp_val equal_comparison_op comp_val

//eval_comparison_op: LESSEQUAL | LESSTHAN | GREATEQUAL | GREATERTHAN
//equal_comparison_op: NOTEQUAL | EQUALS

//comp_val: (integer_result | float_result | string_result | dynamic_result ) identifier


// Assignments
assignment: expression assignment_op expression
assignment_op: ASSIGN|SM_PLUS|SM_MINUS|SM_MULTIPLY|SM_DIVIDE|PLUS|MINUS|MULTIPLY|DIVIDE
var_assignment: identifier opt_vartype opt_assignment

integer_result: integer_result (MULTIPLY | INTDIV | MODULUS) integer_result | integer_result (PLUS | MINUS) integer_result | RBRACE integer_result RBRACE | DEC_NUMBER
float_result: float_result (MULTIPLY | INTDIV | MODULUS) float_result
       | float_result (MULTIPLY | INTDIV | MODULUS) integer_result 
       | integer_result (MULTIPLY | INTDIV | MODULUS) float_result 
       | float_result (PLUS | MINUS) float_result 
       | float_result (PLUS | MINUS) integer_result
       | integer_result (PLUS | MINUS) float_result 
       | RBRACE float_result RBRACE 
       | FLOAT_NUMBER

string_result: string_result MULTIPLY integer_result
       | string_result MULTIPLY string_result
       | string_result PLUS string_result
       | STRING
       
dynamic_result: RBRACE dynamic_result RBRACE
       | dynamic_result (MULTIPLY | INTDIV | MODULUS) dynamic_result
       | integer_result (MULTIPLY | INTDIV | MODULUS) dynamic_result
       | dynamic_result (MULTIPLY | INTDIV | MODULUS) integer_result
       | float_result (MULTIPLY | INTDIV | MODULUS) dynamic_result
       | dynamic_result (MULTIPLY | INTDIV | MODULUS) float_result
       | dynamic_result MULTIPLY string_result
       | string_result MULTIPLY dynamic_result
       | dynamic_result (PLUS | MINUS) integer_result
       | integer_result (PLUS | MINUS) dynamic_result
       | float_result (PLUS | MINUS) dynamic_result
       | dynamic_result (PLUS | MINUS) float_number
       | dynamic_result (PLUS | MINUS) dynamic_result
       | dynamic

dynamic: identifier | array_selector 

array_selector: identifier LBRACK ( integer_result | dynamic_result ) RBRACK

// Declarations
var_declaration: VAR var_assignment
constant_declaration: CONSTANT var_assignment
function_declaration: FUNCTION identifier ( LPAREN opt_arglist RPAREN )? block
class_declaration: CLASS identifier ( LPAREN opt_arglist RPAREN )? block
bind_declaration: BIND identifier AS opt_typelist
let_declaration: LET opt_typelist var_assignment
import_declaration: import_direct | import_from | require_declaration
import_direct: IMPORT string
import_from: FROM string IMPORT string
require_declaration: REQUIRE string
trait_declaration: TRAIT identifier ( LPAREN opt_arglist RPAREN )? block

// Optionals
?vartype: opt_typelist
?opt_vartype: [DOUBLECOLON vartype]
?opt_assignment: [ASSIGN expression]
?opt_typelist: opt_typelist_width | opt_typelist_typed
?opt_typelist_typed: "int" | "float" | "str" | "bool" | "char"
?opt_typelist_width: "int8" | "int16" | "int32" | "int64" | "int128" | "uint8" | "uint16" | "uint32" | "uint64" | "uint128"
?opt_arglist: [arglist]
?opt_call_args: [call_args]
?call_args: call_arg (COMMA call_arg)*
?call_arg: expression

// Arguments and Para
arglist: argument ( (COMMA argument)* )?
argument: stararg identifier opt_vartype opt_assignment
stararg: [MULTIPLY]

// Tokens
terminal: (/\r?\n[\t ]*/)+
//COMMENT: /#[^\n]*/ | OPENBLOCKCOMMENT WS CLOSEBLOCKCOMMENT
COMMENT: HASH /[^\r\n]/*
       | OPENBLOCKCOMMENT /(.|\n|\r)/* CLOSEBLOCKCOMMENT
//ID_LOWER: "a".."z"
//ID_UPPER: "A".."Z"
//ID_LETTER: ID_LOWER | ID_UPPER
//ID_DIGIT: "0".."9"
//IDENTIFIER: ("_"|ID_LETTER) ("_"|ID_LETTER|ID_DIGIT)
identifier: IDENTIFIER
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
newline: (terminal | COMMENT)

//// Symbols
COLON: ":"
DOUBLECOLON: "::"
LPAREN: "("
RPAREN: ")"
LBRACK: "["
RBRACK: "]"
LBRACE: "{"
RBRACE: "}"
COMMA: ","
ELLIPSIS: "..."
INCREMENT: "++"
DECREMENT: "--"
RIGHTARROW: "->" | "=>"
LEFTARROW: "<-" | "<="
DOT: "."
OPENBLOCKCOMMENT: "#+"
CLOSEBLOCKCOMMENT: "#-"
HASH: "#"

//// Operators
ASSIGN: "="
SM_PLUS: "+="
SM_MINUS: "-="
SM_MULTIPLY: "*="
SM_DIVIDE: "/="
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
INTDIV: "//"
WALRUS: ":="
EQUALS: "==" | "is"
NOTEQUAL: "!="
LESSEQUAL: "<="
GREATEQUAL: ">="
LESSTHAN: "<"
GREATERTHAN: ">"
BANG: "!"
EXPONENT: "^"
MODULUS: "%"
VERTICAL: "|"
ATTTRIBUTE: "@@"
PIPE: "|>"
SEMI: ";"
NEGATIVE: "-"
//AMBERSAND : "&"
//DECORATOR : "@"

//// Keywords
TRUE: "true"
FALSE: "false"
VAR: "var"
CONSTANT: "const"
FUNCTION: "fn"
CLASS: "class"
LET: "let"
BIND: "bind" // Permanent, explicit type casting. Example: var x = 5 (x = 5), bind x as float (x = 5.0)
TRAIT: "trait"
END: "end"
ECHO: "echo"
IF: "if"
FOR: "for"
WHILE: "while"
ELSE: "else"
ELIF: "elif"
RETURN: "return"
IN: "in"
AS: "as"
IMPORT: "import"
REQUIRE: "require"
FROM: "from"
DEFINE: "def"
OR: "or" | "||"
AND: "and" | "&&"
NOT: "not"
NIL: "nil"
BREAK: "break"
THIS: "this"

//// Types
DEC_NUMBER: /\d+/
FLOAT_NUMBER: /\d+[.]\d+/
HEX_NUMBER: /0[hx][a-fA-F0-9]*/
STRING: /"(?:[^"\\]|\\.)*"/